// HashTable.cpp file containing methods of the HashTable.h class
// Created by Logan Brennaman on 10/18/21

#define MAXHASH 1000

#include <iostream>
#include "HashTable.h"

using namespace std;

// Constructor to initialize the hashTable with Records. Will be size of #define MAXHASH
template<class T> HashTable<T>::HashTable()
{
    hashTable = new Record<T>[MAXHASH]();
}

/*
 *   INSERT
 *       A hash will be applied to the given key to store the given value into the resulting index provided by the hash function.
 *       Any collisions that occur will be reported back to the user ONLY IF the value can be successfully inserted
 *       Duplicates are not allowed, and the function also cannot insert if the table is full (getSize() == MAXHASH)
 *       IF GRAVESTONE = 1, set GRAVESTONE = -1 if INSERT IS SUCCESSFUL
 */
template<class T> bool HashTable<T>::insert(int key, T value, int& collisions)
{
    // Check if insertion should be done. HashTable can only be inserted into if there is more than 1 space available in HashTable
    // If num_of_entries >= MAXHASH - 1, RETURN FALSE
    if (getSize() >= MAXHASH - 1)
    {
        return false;
    }

    // Use hash function to get key. Store value into the respective record. Array[hashF(k)] <-- value;
    // Do this ^^^ if array[h(k)] does not currently contain a value
    if (hashTable[hashOne(key)].getValue() < 0)
    {
        // It is okay to set value here if there was no value here before
        hashTable[hashOne(key)].setValue(value);

        // If for some reason the gravestone was 1. Reset the gravestone to -1
        hashTable[hashOne(key)].setGrave(-1);

        // Value has been set. Return true
        return true;
    }
    else // Index h(k) contains a Record already. Use probing to find an appropriate offset to add to the key.
    {
        // First check if that value in index h(k) is the same as the value to insert. If so, return false
        if (hashTable[hashOne(key)].getValue() == value)
        {
            return false;
        }

        // The values were not the same, so increment the collisions counter
        int cc = 1; // This is the first time it's used, so if it was 0 before and incremented, it is initially 1

        // Probe to get the offset
        // Something is in index h(k) when that index contains a value that is not the preset value: -1
        // Use the probe function until a value of -1 is found
        bool isTrue = true; // Continue loop until this sentinel declares that the probe found the correct value
        int i = 0;          // Number of attempts
        int offset = 0;     // Offset provided by probe function
        while (isTrue)
        {
            // Get the offset from the probe
            offset = linearProbe(key, i);

            // Break out if the offset of the probe function != -1
            if (offset != -1)
            {
                isTrue = false;
            }
            else // There was a collision this time. Increment cc by 1. Increment attempts by 1. Try again
            {
                cc++;
                i++;
            }
        }

        // The location of h(k) + offset is where the value can be inserted
        hashTable[hashOne(key) + offset].setValue(value);

        // If gravestone == 1 in that location, setGrave to -1
        if (hashTable[hashOne(key) + offset].getGrave() == 1)
        {
            hashTable[hashOne(key) + offset].setGrave(-1);
        }
    }

    // It made it to the end
    // Return TRUE
    return true;
}

/*
 *   REMOVE
 *       A hash will be applied to the given key, allowing for the user to check if there is a RECORD in that location.
 *       If a RECORD is found, set value = to that RECORD, REMOVE THAT RECORD, and return True
 *       Else, return false
 *       SET GRAVESTONE = 1 upon SUCCESSFUL REMOVAL
 */
template<class T> bool HashTable<T>::remove(int key, T& value)
{
    // If value in index hashF(key) contains a value (I.e. if value >= 0), there is a record there. Remove it
    if (hashTable[hashOne(key)].getValue() >= 0)
    {
        // Set value = the value of the record
        value = hashTable[hashOne(key)].getValue();

        // Remove the record (In the case of my code, this means setting the value to a negative number. Set to -1
        hashTable[hashOne(key)].setValue(-1);

        // Set grave of index hashF(key) to 1
        hashTable[hashOne(key)].setGrave(1);

        // It is now okay to return true;
        return true;
    }

    // If it made it here, index hashF(key) contained no value to remove. Return FALSE
    return false;
}

/*
 *   FIND
 *       A hash will be applied to the given key, allowing for the user to check if there is a RECORD in that location.
 *       If a RECORD is found, set value = to a COPY of that RECORD, return TRUE
 *       Else, return false
 */
template<class T> bool HashTable<T>::find(int key, T& value)
{
    // If value in index hashF(key) contains a value (I.e. if value >= 0), there is a record there.
    if (hashTable[hashOne(key)].getValue() >= 0)
    {
        // When there is a record, copy getValue() into value
        value = hashTable[hashOne(key)].getValue();

        // Return true
        return true;
    }

    // If it made it here, there was no record in that location. Return FALSE
    return false;
}

// alpha - returns getSize() / MAXHASH
template<class T> float HashTable<T>::alpha()
{
    return ((float)getSize() / (float)MAXHASH);
}

// getSize() - counts all initialized Records in the HashTable and returns that count
template<class T> int HashTable<T>::getSize()
{
    // Start a count
    int count = 0;

    // Iterate through the entire array
    for (int i = 0; i < MAXHASH; i++)
    {
        // If the Record at the current index, i, has a value, increment count by 1
        if (hashTable[i].getValue() != -1)
        {
            count++;
        }
    }

    // Return how many Records were counted
    return count;
}

// hashOne: returns key % MAXHASH
template<class T> int HashTable<T>::hashOne(int key)
{
    return key % MAXHASH;
}

// hashTwo: returns (key + getSize()) % MAXHASH
template<class T> int HashTable<T>::hashTwo(int key)
{
    return (key + getSize()) % MAXHASH;
}

// hashThree: returns (key / getSize()) % MAXHASH
// Used by doubleHashProbe()
template<class T> int HashTable<T>::hashThree(int key)
{
    return (key / getSize()) % MAXHASH;
}

// LinearProbe
// Views Record stored in current hashTable[hash(key) + attempts], if that Record's value is empty
// Return attempts, else -1 to signify that the key was not empty and that the code must progess
template<class T> int HashTable<T>::linearProbe(int key, int attempts)
{
    if (hashTable[hashOne(key) + attempts].getValue() == -1)
    {
        return attempts;
    }
    return -1;
}

// Double-hash probe: calculates a relatively prime number to use as a probe using hashThree
// Views Record stored in hashTable[hash(key) + offset]. If that Record's value is empty,
// Returns offset, else -1 to signify that the key was not empy and that the code must progress
template<class T> int HashTable<T>::doubleHashProbe(int key, int attempts)
{
    // Get the offset by multiplying the number of attempts by hashThree
    int offset = attempts * hashThree(key);

    // Make sure that the offset is relatively prime
    while (MAXHASH % offset == 0)
    {
        offset++; // increment offset until MAXHEAP is not evenly divisible by offset
    }

    // View hashTable[hash(key) + offset]
    if (hashTable[hashOne(key) + offset].getValue() == nullptr)
    {
        return offset;
    }
    return -1;

}

// Overriding the << operator to print all of the records held in the HashTable
// Writing "cout << *hashtable" will print the hashtable
template<class U> ostream& operator<<(ostream& os, const HashTable<U>& hash)
{
    os << "HASHTABLE\n____________\n";
    for (int i = 0; i < MAXHASH; i++) {
        if (hash.hashTable[i].getValue() != -1)
        {
            os << i << " | " << hash.hashTable[i].getValue();
        }
    }
    return os;
}