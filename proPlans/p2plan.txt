CS 3100 – Data Structures and Algorithms
Project #2 – Directory Tree

Learning Objectives
• Apply basic object-oriented programming concepts in C++
• Design, implement, and use a general tree data structure
• Analyze operations for time complexity

Overview
    The directory (folder) structure on a computer can be represented as a general tree. Your task for
project 2 is to simulate this. We discussed four different ways to implement a general tree during lecture
— you may use any of these for your project.
Your program should not place any limits on the breadth or depth of the directory tree.
You should write a driver program creates a single directory called “root” and then continually waits for
the user to type in a command and performs the requested action. Your program must support the
commands listed below. The program should end if the user types “quit”, and it should display the
message “Unknown command” if the user enters anything that is not in this list (other than “quit”). The
commands should be considered case-sensitive (i.e. if the user types in LS instead of ls, the program
should output “Unknown command”).
Your code should contain a comment explaining the worst-case asymptotic time complexity of each
operation listed below.

Available Commands:
    • pwd — this should display the name of the current directory

    • ls —this should display the names of all children of the current directory; if the current directory
has not subdirectories, display the message “This directory is empty” (note that the ‘l’ is a
lowercase L)

    • exists <directory> — displays the message “<directory> exists” if <directory> exists anywhere in
the directory structure; otherwise displays the message “<directory> does not exist”. Note that
you may have more than one directory with the same name. This command should say the
directory exists if there is at least one directory with the specified name.

    • cd <new_directory> — this should change the current directory to <new_directory> but only if
<new_directory> is a child of the current directory; otherwise it should display the message
“<new_directory> not found”.

    • cd .. — the special command cd .. should change the current directory to the parent of the one
you are in when the command is entered. If you are already in the root directory, this command
should display the message “You are in the root directory”

    • mkdir <new_directory> — this should create a new directory named <new_directory> whose
parent is the current directory

    • rmdir <directory_to_remove> — this should remove <directory_to_remove> and all of its
subdirectories but only if <directory_to_remove> is a child of the current directory; otherwise it
should display the message “<directory_to_remove> not found”.

    • countdir — should display the number of directories in the subtree rooted at the current
directory (i.e. the number of descendants of the current directory + 1)

Extra Credit:
    • showtree — this should display the current directory and all of its descendants using a pre-order
traversal, with each directory name tabbed over based on its depth (i.e. the children of the
current directory should be tabbed over one, the children of those directories tabbed over two,
and so on)

Turn in and Grading
    Please turn in all .h and .cpp files that you write for this project into the dropbox on Pilot. Please do not
zip or compress your files.
Your project will be graded according to the following rubric. The number in [ ] is the number of points
each item is worth. Projects that do not compile will receive a zero.

[10] Driver program reads user commands and responds differently based on which command was
entered. The program halts if the user enters ‘quit’.

[10] You have implemented a workable general tree (at a minimum you can add items to it) and there is
no limit on its breadth or depth, nor any memory leaks.

[80] Each of the eight commands listed under “Available Commands” is worth nine points for a correct
implementation, plus one point for correctly stating its time complexity.

Extra Credit: Correct implementation of the showtree command is worth an additional 9 points of extra
credit, and correctly stating its time complexity is worth one additional point of extra credit.

---------------------------------------------------------------------------------------------------------------

Understanding the methods of the gTree class

pwd - Displaying the PATH of the current directory
    Start at current's node
        Store current's value in a string + "/", pass it to the parent
    At the parent,
        Parent value + "/" + append value passed from child, pass it to the parent
    Repeat this process until root is reached
        Root + Series of parent value + "/" + child value + "/"

ls - Display all siblings of this node. To do this, go up to parent, print all children.
    If this is not possible, i.e. there are no siblings:                                            NOOOOOOOOOOOOOOO
        Print "This directory is empty"

exists arg - If one directory of parameter, arg, exists, print:
                "[arg] exists"
            Otherwise:
                "[arg] does not exist"

cd arg - Look to see if arg is a child of the current node. If so, change current directory to the new directory
        Else print:
            "[arg] not found"
        Special Case:
            If arg == ..
                Change current directory to parent directory
            Else, if in root:
                Print:
                    "You are already in the root directory"

mkdir arg - makes a new directory [arg] whose parent directory is the current directory. Current has a new child, arg

rmdir arg - If arg is child of current directory, remove directory and all of its children.
            Else print:
                "[arg] to remove not found"

countdir - Display number of descendents + 1 (current directory)

showtree - this should display the current directory and all of its descendants using a pre-order
        traversal, with each directory name tabbed over based on its depth (i.e. the children of the
        current directory should be tabbed over one, the children of those directories tabbed over two,
        and so on)

---------------------------------------------------------------------------------------------------------------

Coding the methods of the gTree class

pwd - Displaying the PATH of the current directory
    Start at current's node
        Store current's value in a string + "/", pass it to the parent
    At the parent,
        Parent value + "/" + append value passed from child, pass it to the parent
    Repeat this process until root is reached
        Root + Series of parent value + "/" + child value + "/"

pwd()
{
    // Go all the way to the parent
    // On the way back down, take the value of the current node and add it into a string to return
    return getValue + "/" + parent->pwd();
}


ls - Display all children of this node. To do this, go through each node of linkedlist and print values
    If this is not possible, i.e. there are no children:
        Print "This directory is empty"

ls()
{

}


exists arg - (CHECKS WHOLE TREE) If one directory [arg] exists, print:
                "[arg] exists"
            Otherwise:
                "[arg] does not exist"

exists(arg)
{
    // Preorder Traversal
    // Check value (type T) of root node. If not, go to left-most value of LinkList
    // Check value of current node. If not, go to left-most value of LinkList
    // Do this recursively until there is no longer any left.
    // Go right if possible. If not retreats recursively. Goes right if possible. That's the idea
    // Make it a boolean? return 1 if found?

    // Code assuming it is a boolean
    if (getValue() == arg)
        return 1;
    else
    {
        Node<T>* current = getList()->getHead();
        while (current != nullptr)
        {
            // Look at the gTree value held in the LinkedList
            current->getValue().exists(arg);
        }
    }

}


cd arg - Look to see if arg is a child of the current node. If so, change current directory to the new directory
        Else print:
            "[arg] not found"
        Special Case:
            If arg == ..
                Change current directory to parent directory
                Else, if in root:
                    Print:
                        "You are already in the root directory"

cd(arg)
{
    // Check for the special case first
    if (arg == "..")
    {
        // Make sure that the user isn't already in the root directory
        if (parent == nullptr) // Must be "if parent is null" because more than one "root" can theoretically be created
        {
            // If there is no parent, then the user is in root. Cannot go back a directory
            cout << "You are already in the root directory" << endl;
        }
        else // User can go back a directory, so go back
        {
            return this->getParent();
        }
    }
    else // It was not the special case. Check if [arg] is a child of this. If so, return the child's address
    {
        // Iterate through this->getList() in search of [arg].
        Node<gTree<T>>* current = getList()->getHead();
        while (current != nullptr)
        {
            // Look at the gTree value held in the LinkedList
            if (current->getValue() == arg)
            {
                return current;
            }

            // If the current's value wasn't [arg], progress to next node
            current = current.getNext();
        }
    }

    // If a value hasn't been returned yet, then [arg] was not a child of this node. Return 0 to show this
    return 0;
}


mkdir arg - makes a new directory [arg] whose parent directory is the current directory. Current has a new child, arg

    For this linked list implementation of a gTree, when adding a child, use the current node's list's add method to add an arg of type gTree<T>*

mkdir(arg)
{

    // Use the add method of this node's linked list
    this->getList()->add(arg);

}

rmdir arg - If arg is child of current directory, remove directory and all of its children.
            Else print:
                "[arg] to remove not found"

rmdir(arg)
{
    // Cycle through linked list and look for [arg]
    Node<gTree<T>*>* current = getList()->getHead();

    // Keep track of previous node as well as the current node
    Node<gTree<T>*>* previous = current;

    // Look through list until a null pointer is reached
    while (current != nullptr)
    {
        // Look at the gTree value held in the LinkedList
        if (current->getValue()->getValue() == arg)
        {
            // The node must be deleted, but pointers must be changed to keep the list intact.
            // Set previous's pointer to current's next
            if (previous != current)
            {
                previous->setNext(current->getNext());

                // Current node can now be deleted
                delete current;
            }
            else if (previous == current) // If they were both the same, that means the head was deleted. Set a new head
            {
                getList()->setHead(current->getNext());
                delete current;
            }
            else if (current == getList()->getTail())
            {
                // Set previous's next to null because there is no next anymore
                previous->setNext(nullptr);
                delete current;
            }
        }

        // If the current's value wasn't [arg], progress to next node
        previous = current;
        current = current.getNext();
    }
}

countdir - Display number of descendents + 1 (current directory)

        Entire subtree or just children??????????????????????????????????

countdir()
{
    // Progress through each tree and add the totals of their list's count method
    int count = 1; // Start by counting the current node

    // Iterate through this->getList() in search of [arg].
    Node<gTree<T>>* current = getList()->getHead();
    while (current != nullptr)
    {
        // Look at the gTree value held in the LinkedList
        count += current->getValue()->countdir();

        // If the current's value wasn't [arg], progress to next node
        current = current.getNext();
    }

    return count;
}

showtree - this should display the current directory and all of its descendants using a pre-order
        traversal, with each directory name tabbed over based on its depth (i.e. the children of the
        current directory should be tabbed over one, the children of those directories tabbed over two,
        and so on)

showtree(tabNum)
{
    // Preorder traversal
    // First thing that happens is that the node is printed
    // Depending on level, controlled by the param tabNum, print the appropriate number of tabs before the node
    for (int i = 0; i < tabNum; i++)
    {
        cout << "\t";
    }
    
    // Print node
    cout << this->getValue() << endl;
    
    // Traversal
    // Traversing a linked list through iteration
    Node<gTree<T>>* current = getList()->getHead();
    while (current != nullptr)
    {
        // Going down a level. Pass tabNum+1
        current->getValue->showtree(tabNum+1);

        // Progress to next node
        current = current->getNext();
    }
}
// Note that all of the above code is NOT FINAL and contains various errors ranging from syntax errors to logic errors
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// Note that all of the above code is NOT FINAL and contains various errors ranging from syntax errors to logic errors
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
// Note that all of the above code is NOT FINAL and contains various errors ranging from syntax errors to logic errors